<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>INFO 4310 HW 2</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    h1, h2, h3, h4{
      text-align: center;
    }
    .flex{
      display: flex;
      flex-direction: row;
    }
    .column1, .column2{
      /*border-style: solid;*/
    }
    .column1{
      width: 60%;
    }
    .column2{
      width: 40%;
    }
    .gridlines line {
      stroke: #bbb;
    }
    .gridlines .domain {
      stroke: none;
    }
  </style>

<body style="font-family: 'Quicksand', sans-serif;">
    <h2> Visualizing Natural Disasters Across the World</h2>
    <h3> 1900 - 2021</h3>
    <div class="flex">
      <div class="column1"> 
        <svg id="barGraph" height=600 width=850></svg>
        <svg id="lineGraph" height="600" width="850"> </svg>
      </div>
      <div class="column2"> 
        <h4> Controls: </h4>
        <div id="legend" style="position: fixed; top: -70; left: 1050;"> </div>
      </div>
    </div>
    
    <script>
      // bar chart setup 
      let barGraph = d3.select('svg#barGraph');
      const barTotalWidth = barGraph.attr("width");
      const barTotalHeight = barGraph.attr("height");
      const barGraphMargin = {
        top: 10,
        right: 10,
        bottom: 120,
        left: 70
      };
      const barGraphWidth = barTotalWidth - barGraphMargin.left - barGraphMargin.right;
      const barGraphHeight = barTotalHeight - barGraphMargin.top - barGraphMargin.bottom - 10;
      let barGraphAnnotations = barGraph.append("g").attr("id", "annotations");


      // line graph setup
      let lineGraph = d3.select('svg#lineGraph');
      const lineTotalWidth = lineGraph.attr("width");
      const lineTotalHeight = lineGraph.attr("height");
      const lineGraphMargin = {
        top: 10,
        right: 10,
        bottom: 120,
        left: 70
      };
      const lineGraphWidth = lineTotalWidth - lineGraphMargin.left - lineGraphMargin.right;
      const lineGraphHeight = lineTotalHeight - lineGraphMargin.top - lineGraphMargin.bottom - 10;
      let lineGraphAnnotations = lineGraph.append("g").attr("id", "annotations");
      let lineGraphArea = lineGraph.append("g").attr("id","points")
                                    .attr("transform",`translate(${lineGraphMargin.left},${lineGraphMargin.top})`);

      const requestData = async function () {
        let disasters = await d3.csv("disasters_processed.csv", d3.autoType);
        console.log(disasters);

        // list of all regions we will look at 
        const regionList = [
          "Southern Asia", 
          "South-Eastern Asia", 
          "Eastern Asia", 
          "South America", 
          "Northern America", 
          "Eastern Africa", 
          "Central America",
          "Western Africa",
          "Southern Europe",
          "Caribbean",
          "Western Asia",
          "Eastern Europe",
          "Western Europe",
          "Middle Africa",
          "Oceania Islands",
          "Northern Africa",
          "Australia and New Zealand",
          "Northern Europe",
          "Southern Africa",
          "Central Asia"
        ];

        const disasterList = ["Flood", "Storm", "Earthquake", "Epidemic", "Landslide"];
        
        let regionDisasterCounts = [];
        regionList.forEach(region => {
          regionDisasterCounts.push({
            Region: region,
            Flood: 0,
            Storm: 0,
            Earthquake: 0,
            Epidemic: 0,
            Landslide: 0,
            1900: 0,
            1910: 0, 
            1920: 0,
            1930: 0, 
            1940: 0, 
            1950: 0,
            1960: 0,
            1970: 0,
            1980: 0,
            1990: 0,
            2000: 0,
            2010: 0,
            2020: 0,
            Total: 0
        });
        } );

        // if the region AND type matches then add one to the count 
        function regionDisasterCount(d, type) {
          regionDisasterCounts.forEach( regionOfObj => {
            if (d.region == regionOfObj.Region & d.disaster_type == type) {
              regionOfObj[type] += 1
              regionOfObj["Total"] += 1
              regionOfObj[d.decade] += 1
            }
          })
        }

        disasters.forEach( d => {
          if (disasterList.includes(d.disaster_type))
            regionDisasterCount( d, "Flood");
            regionDisasterCount( d, "Storm");
            regionDisasterCount( d, "Earthquake");
            regionDisasterCount( d, "Epidemic");
            regionDisasterCount( d, "Landslide");
        })

        console.log(regionDisasterCounts);

        // // Set up scales
        let regionScale = d3.scaleBand().domain(regionList).range([0,barGraphWidth]).padding(0.05)
        console.log("region test:", regionScale("Central Asia"))

        const percentScale = d3.scaleLinear()
                                .domain([0, 1])
                                .range([0, barGraphHeight]);

        colorPalette = ["#00c2de", "#fa8901", "#808080", "#f43545", "#97572b"]
        const scaleOrdinal = d3.scaleOrdinal(colorPalette);

        // // Create axes and axis labels

        let bottomAxis = d3.axisBottom(regionScale);
        barGraphAnnotations.append('g')
          .attr('class', 'x axis')
          .attr('transform', `translate(${barGraphMargin.left}, ${barGraphHeight + barGraphMargin.top + 10})`)
          .call(bottomAxis)
          .selectAll("text") 
          .style("text-anchor", "end")
          .attr("transform", "translate(-10, 2) rotate(-65)");

        let leftAxis = d3.axisLeft(percentScale);
        barGraphAnnotations.append('g')
          .attr('class', 'y axis')
          .attr('transform', `translate(${barGraphMargin.left - 10}, ${barGraphMargin.top})`)
          .call(leftAxis.tickFormat(p => {
            return Math.round((1 - p) * 100) + "%";
          }));

        barGraphAnnotations.append("text")
          .attr("class", "x label")
          .attr("text-anchor", "middle")
          .attr("x", (barGraphWidth / 2) + barGraphMargin.left)
          .attr("y", barGraphHeight + barGraphMargin.top + barGraphMargin.bottom)
          .text("Region");

        barGraphAnnotations.append("text")
          .attr("class", "y label")
          .attr("text-anchor", "middle")
          .attr("y", 5)
          .attr("x", -barGraphHeight / 2 + barGraphMargin.top)
          .attr("dy", ".6em")
          .attr("transform", "rotate(-90)")
          .text("Percent of Disasters");

        // Create bars (only if disaster has at least 1% in a region)

        let rectWidth = barGraphWidth / 20;

        regionDisasterCounts.forEach((regionObj, i) => {
          total = regionObj["Total"];
          region = regionObj["Region"]
          region.replace(" ", "");
          let nextFloor = 0;
          for (let c in regionObj) {
            wanted_bars = ['Earthquake', 'Epidemic', 'Flood', 'Landslide', 'Storm'];
            if ( wanted_bars.includes(c) ) {
              percent = regionObj[c] / total;
                barGraph.append("rect")
                  .attr("x", regionScale(region) + barGraphMargin.left)
                  .attr("y", nextFloor + barGraphMargin.top)
                  .attr("originalPosition", nextFloor + barGraphMargin.top)
                  .attr("width", rectWidth)
                  .attr("height", percentScale(regionObj[c] / total))
                  .style("fill", scaleOrdinal(c))
                  .attr("originalFill", scaleOrdinal(c))
                  .attr("class", `bar ${c} ${region}`);
                nextFloor += percentScale(regionObj[c] / total);
            }
          }
        })

        // LEGEND FUNCTIONS //
        let fixedLegend = d3.select("#legend")
        for (let i = 0; i < disasterList.length; i++) {
          let text = fixedLegend.append("text")
            .style("position", "absolute")
            .text(disasterList[i])
            .style("right", 80)
            .style("top", 190 + i * 34)
            .style("height", 50)
            .style("padding-top", "16px")
            .style("text-align", "right")
            .style("color", scaleOrdinal(disasterList[i]));
          let box = fixedLegend.append("rect")
            .style("background", scaleOrdinal(disasterList[i]))
            .style("position", "absolute")
            .style("right", 40)
            .style("top", 200 + i * 34)
            .style("width", 20)
            .style("height", 20)
          let container = fixedLegend.append("rect")
            .style("position", "absolute")
            .style("opacity", 0)
            .style("right", 40)
            .style("top", 200 + i * 34)
            .style("width", 140)
            .style("height", 50)
          container.on("mouseover", function () {
            disappear(disasterList[i])
            //disappearRegion("SouthernAsia")
          }).on("mouseout", function () {
            reappearAll()
          });
        }
        // Graph manipulation functions

        // Hides all consoles except c
        function disappear(c) {
          let barMover = d3.selectAll('.bar')
            .filter(function () {
              return !this.classList.contains(c)
            });
          let op = 0;
          barMover._groups.forEach(bar => {
            bar.forEach((r, i) => {
              d3.select(r).transition().duration(200)
                .attr("opacity", 0.0);
            })
          })
          barMover = d3.selectAll(`.${c}`);
          barMover.style("fill", scaleOrdinal(c));
          let h = 0;
          barMover._groups.forEach(bar => {
            bar.forEach((r, i) => {
              h = r.getAttribute("height");
              d3.select(r).transition().duration(500)
                .attr("opacity", 1)
                .attr("y", barGraphHeight - h + barGraphMargin.top);
            })
          })
        }

        // Returns graph to original position
        function reappearAll() {
          let barMover = d3.selectAll('.bar');
          let op = 0;
          let f = "";
          barMover._groups.forEach(bar => {
            bar.forEach((r, i) => {
              op = r.getAttribute("originalPosition");
              f = r.getAttribute("originalFill");
              d3.select(r).transition().duration(200)
                .attr("y", op)
                .attr("opacity", 1);
            })
          })
        }

        // LINE CHART

        const lineGraphTimeParser = d3.timeParse('%Y');
        // we already know the range of dates
        const dateExtent = [lineGraphTimeParser('1900'), lineGraphTimeParser('2021')];
        const countExtent = [0,2000];
        const countScale = d3.scaleLinear().domain(countExtent).range([lineGraphHeight, 0]);
        const dateScale = d3.scaleTime().domain(dateExtent).range([0,lineGraphWidth]);

        let lineGraphLeftAxis = d3.axisLeft(countScale);
        let lineGraphLeftGridlines = d3.axisLeft(countScale)
                                      .tickSize(-lineGraphWidth-10)
                                      .tickFormat("");
        lineGraphAnnotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform",`translate(${lineGraphMargin.left-10},${lineGraphMargin.top})`)
                    .call(lineGraphLeftAxis)
        lineGraphAnnotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform",`translate(${lineGraphMargin.left-10},${lineGraphMargin.top})`)
                    .call(lineGraphLeftGridlines);

        let lineGraphBottomAxis = d3.axisBottom(dateScale)
        let lineGraphBottomGridlines = d3.axisBottom(dateScale)
                                        .tickSize(-lineGraphWidth-10)
                                        .tickFormat("")
        lineGraphAnnotations.append("g")
                  .attr("class", "x axis")
                  .attr("transform",`translate(${lineGraphMargin.left},${lineGraphHeight+lineGraphMargin.top+10})`)
                  .call(lineGraphBottomAxis);
        lineGraphAnnotations.append("g")
                  .attr("class", "x gridlines")
                  .attr("transform",`translate(${lineGraphMargin.left},${lineGraphHeight+lineGraphMargin.top+10})`)
                  .call(lineGraphBottomGridlines);

        let lineGraphgTags = lineGraphArea.selectAll("g.g-tags").data(regionDisasterCounts)
                            .join("g")
                            .attr("class", "g-tags")
                            // .style("stroke", d => colorScale(d['track']));

        // try and figure out the lines in Danny's way ??
        regionDisasterCounts.forEach((regionObj, i) => {
          total = regionObj["Total"];
          region = regionObj["Region"]
          region.replace(" ", "");
          let nextFloor = 0;
          for (let c in regionObj) {
            wanted_bars = ['Earthquake', 'Epidemic', 'Flood', 'Landslide', 'Storm'];
            if ( wanted_bars.includes(c) ) {
              percent = regionObj[c] / total;
                barGraph.append("rect")
                  .attr("x", regionScale(region) + barGraphMargin.left)
                  .attr("y", nextFloor + barGraphMargin.top)
                  .attr("originalPosition", nextFloor + barGraphMargin.top)
                  .attr("width", rectWidth)
                  .attr("height", percentScale(regionObj[c] / total))
                  .style("fill", scaleOrdinal(c))
                  .attr("originalFill", scaleOrdinal(c))
                  .attr("class", `bar ${c} ${region}`);
                nextFloor += percentScale(regionObj[c] / total);
            }
          }
        })

        // var lineGen = d3.line()
        //                 .x( d => dateScale(lineGraphTimeParser(d['year']) ))
        //                 .y( d => countExtent(d['Carbon Dioxide (ppm)']) )
        //                 .curve(d3.curveMonotoneX); 

        // lineGraphArea.append("path")
        //             .datum(regionDisasterCounts)
        //             .attr("class", "line")
        //             .attr("fill", "none")  
        //             .attr("stroke", "steelblue")
        //             .attr("stroke-width", 3)
        //             .attr("d", lineGen);

      }

      requestData();


    </script>
</body>
</html>
